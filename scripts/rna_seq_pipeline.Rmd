---
title: "rna_seq_pipeline"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Quality check the raw reads using fastqc
```{bash}
# First create the directory where quality reports will be directed
mkdir ../quality_reports
mkdir ../quality_reports/quality_recheck_reports/  #reports generated after sequence trimming will be saved in this directory

fastqc -o ../quality_reports *.fastq #fastqc command

```
Trim reads with low quality and remove adapters if present using trimmomatic
```{bash}
for R1 in *R1* 
do
	R2=${R1//R1.fastq/R2.fastq}
	R1_paired=${R1//.fastq/_paired.fastq}
	R1_unpaired=${R1//.fastq/_unpaired.fastq}
	R2_paired=${R2//.fastq/_paired.fastq}
	R2_unpaired=${R2//.fastq/_unpaired.fastq}
	trimmomatic PE $R1 $R2 $R1_paired $R1_unpaired $R2_paired $R2_unpaired -summary summary.txt -trimlog logfile SLIDINGWINDOW:4:20 MINLEN:20 ILLUMINCACLIP:NexteraPE-PE.fa:2:40:15 
done
```
Perform quality recheck after trimming using fastqc
```{bash}

fastqc -o  ../quality_reports/quality_recheck_reports *_paired.fastq

```
Perform pseudo-alignment and generate gene counts using kallisto
```{bash}
# create a kallisto index

kallisto index -i kallisto_index Homo_sapiens.GRCh38.cdna.abinitio.fa.gz

# now run kallisto

for sample in *R1_paired.fastq*
do
	R2=${sample//_R1_paired.fastq/_R2_paired.fastq}
	kallisto quant -i ../Kallisto/kallisto_index -b 30 -o ./  ${sample} $R2
done

```

From here, we transfer kallisto output for analysis on R using DESeq2

```{r}

library(tximportData) 

dir <- system.file("extdata", package = "tximportData") # locate the directory containing the files

list.files(dir) # list files

```

create a named vector pointing to the abundace files
```{r}
samples <- read.table(file.path(dir, "samples.txt"), header = TRUE)
samples
```

Importing kallisto abundance.h5 file
```{r}
library(rhdf5) # needed to read abundance.h5

library(tximport) # imports abundance.h5

files <- file.path(dir, "kallisto_boot", samples$run, "abundance.h5")

names(files) <- paste0("sample", 1:6)

txi.kallisto <- tximport(files, type = "kallisto", txOut = TRUE)

head(txi.kallisto$counts)

```
We have now imported our abundance.h5 file, next we create a DESegDataSet(dds) for use with DESeq2.
```{r}
library(DESeq2)
# import file with metadata of our samples

metadata <- read.csv('practice.dataset.metadata.csv', sep = '\t', row.names = 1, header = T, stringsAsFactors = T)

metadata

# setting reference level to 'normal'

metadata$Condition <- relevel(metadata$Condition, ref = 'normal')
metadata
```
Define rownames and columnnames of our dds

```{r}
rownames(metadata) <- colnames(txi.kallisto$counts)
```

Generating DeseqDataFrame
```{r}
dds <- DESeqDataSetFromTximport(txi.kallisto, metadata, ~ Condition)
```

Normalize counts and generate estimates of size factors
```{r}
dds <- DESeq(dds)
```
Extract results from dds
```{r}
deseq_results <- results(dds)
head(deseq_results, 10)
nrow(deseq_results)

```

Our count matrix contains many rows with only zeros, we need to remove the rows that have no information about the amount of gene expression, this will also increase the speed of our function. 
```{r}
deseq_results <- rowSums(counts(dds)) > 1

dds <- dds[deseq_results,]

nrow(dds)

```

Data transformation
```{r}
vsd <- vst(dds, blind = FALSE) # Variance Stabilizing Transformation

rld <- rlog(dds, blind = FALSE) #regularized logarithm

```

View generated matrices
```{r}
head(assay(vsd), 3)
head(assay(rld), 3)

```

Examine the effects of transformation on the variance
```{r}
library(vsn)
# Before transformation
untransformed_dds <- normTransform(dds)
untransformed_dds_plot <- meanSdPlot(assay(untransformed_dds))


vsd_plot <- meanSdPlot(assay(vsd))
```

After Variance Stabilizing Transformation

```{r}
vsd_plot <- meanSdPlot(assay(vsd))
vsd_plot
```

After regularized logarithm transformation
```{r}
rld_plot <- meanSdPlot(assay(rld))
rld_plot
```

Generate the heatmap of the count matrix to explore the count matrix
```{r}
library(pheatmap)
library(RColorBrewer)
row_means <- order(rowMeans(counts(dds, normalized = TRUE)), decreasing = TRUE)[1:20]

data_frame <- as.data.frame(colData(dds))

qc_pheatmap_plot <- pheatmap(assay(vsd)[row_means,], cluster_rows = FALSE, show_rownames = FALSE, cluster_cols = FALSE, annotation_col = data_frame)

qc_pheatmap_plot
```

Plot sample distance matrix to assess overall similarity between samples
```{r}
sample_distance <- dist(t(assay(vsd))) # Calculate distances between samples
sample_distance_matrix

```

Converting the dist object to matrix
```{r}
sample_distance_matrix <- as.matrix(sample_distance)
rownames(sample_distance_matrix) <- paste(vsd$Condition)
colnames(sample_distance_matrix) <- rownames(metadata)

```

Set colors
```{r}
colors <- colorRampPalette(rev(brewer.pal(9, 'Reds'))) (255)

```

Now generate pheatmap

```{r}
distance_pheatmap_plot <- pheatmap(sample_distance_matrix, clustering_distance_rows = sample_distance, clustering_distance_cols = sample_distance, col = colors)

distance_pheatmap_plot
```

PCA plots: to visualize distances between sample in a 2D plane
```{r}
vsd_pca_plot <- plotPCA(vsd, intgroup = 'Condition')

vsd_pca_plot

```

